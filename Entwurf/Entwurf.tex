\documentclass[a4paper,12pt]{article}
\usepackage{amssymb} % needed for math
\usepackage{amsmath} % needed for math
\usepackage[utf8]{inputenc} % this is needed for german umlauts
\usepackage[ngerman]{babel} % this is needed for german umlauts
\usepackage[T1]{fontenc}    % this is needed for correct output of umlauts in pdf
\usepackage[margin=2.5cm]{geometry} %layout
\usepackage{booktabs}
\usepackage[hidelinks]{hyperref}
\hypersetup{pdftitle={Balanced Banana},bookmarks=true,}
\usepackage{graphicx}
\usepackage{csquotes}
\usepackage[nonumberlist]{glossaries}
\usepackage{enumitem}
\usepackage{verbatim}
\usepackage{indentfirst} % Adds indent for the first paragraph after a {/section}
\usepackage{url}
\newcommand\purl[1]{\protect\url{#1}}



\deftranslation[to=ngerman]{Glossary}{\section{Stichwortverzeichnis}}

\makeatletter
\newenvironment{mycode}
 {\def\@xobeysp{\ }\verbatim\rightskip=0pt plus 6em\relax}
 {\endverbatim}
\makeatother

\setitemize{align=parleft, labelsep=0.5cm}


\makenoidxglossaries



\title{Balanced Banana}
\author{Niklas Lorenz \and Thomas Häuselmann \and Rakan Zeid Al Masri \and Christopher Lukas Homberger \and Jonas Seiler}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create a shorter version for tables. DO NOT CHANGE               	 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\addrow[2]{#1 &#2\\ }

\newcommand\addheading[2]{#1 &#2\\ \hline}
\newcommand\tabularhead{\begin{tabular}{lp{13cm}}
\hline
	}

\newcommand\addmulrow[2]{ \begin{minipage}[t][][t]{2.5cm}#1\end{minipage}%
   &\begin{minipage}[t][][t]{8cm}
    \begin{enumerate} #2   \end{enumerate}
    \end{minipage}\\ }

\newenvironment{usecase}{\tabularhead}
{\hline\end{tabular}}

\usepackage{microtype}

\begin{document}
\pagenumbering{roman}
\input{Deckblatt}         % Deckblatt.tex laden und einfügen
\setcounter{page}{2}
\tableofcontents          % Inhaltsverzeichnis ausgeben
\clearpage
\pagenumbering{arabic}

% Document starts here.
\section{Einleitung}
\vspace{1cm}

% Here

\clearpage
\section{Aufbau}

\subsection{Architektur}
% Hier soll die verschiedenen Teile unseres Programms erklärt werden.

\subsubsection{Datenbank}

	Die Datenbank enthält relevante Daten über verschiedene Entitäten in unserem Programm. Mit Hilfe von SQL-Queries kann unser Programm diese Daten abrufen und sinnvoll nutzen.  Unsere Datenbank verwendet ein relationales Datenbank-Managementsystem, um Informationen in verschiedenen Tabellen zu speichern. Darüber hinaus sind die Tabellen über Beziehungen miteinander verbunden, die den Sinn der Daten weiter verdeutlichen. Nachfolgend finden Sie ein Entity-Relationship-Diagramm, das zeigt, wie unsere Datenbank konzipiert ist:

\includegraphics[width=\textwidth]{database_relational}

Die Datenbank ist in drei verschiedene Klassen unterteilt: Die Repository-, die Gateway- und die Factory-Klasse. Die Gateway-Klasse verwendet das Qt-Framework, um sich mit der Datenbank zu verbinden und die SQL-Queries durchzuführen. Die Factory-Klasse ist für die Erstellung von Objekten aus den vom Gateway zurückgegebenen Daten verantwortlich. Das Repository nutzt beide Klassen und dient als Schnittstelle für den Zugriff auf die Datenbank.


\subsection{Klassendiagramm}

% Übersicht aller Klassendiagramme




\clearpage
\section{Klassenbeschreibung}

\iffalse
Format:
\subsubsection{Klasse}

Kurze Beschreibung

\begin{itemize}[label={}]

	\item \textit{\textbf{Attribute}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{name} beschreibung
		\end{itemize}

	\item \textit{\textbf{Methoden}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{signatur} beschreibung
		\end{itemize}


\end{itemize}

\fi
\subsection{Datenbank}
\subsubsection{Model}
%Show the class diagram for it first



\subsubsection{Repository}

Die Repository-Klasse ist die Schnittstelle, die der Rest des Programms verwendet, um SQL-Queries durchzuführen und deren Ergebnisse zu interpretieren. Es verwendet die Gateway-Klasse, um die SQL-Queries durchzuführen und erzeugt ein Objekt, indem es der Factory-Klasse die von Gateway zurückgegebenen Daten gibt.

	\begin{itemize}[label={}]
	
		\item \textit{\textbf{Methoden}}
			\begin{itemize}[label={\textbullet}]
				\item \textit{public uint64\_t addWorker(int auth\_key, int space, int ram, int cores, std::string address)} Fügt einen Worker zur Datenbank hinzu und gibt seine ID zurück.
				
				\item \textit{public bool removeWorker(uint64\_t id)} Löscht einen Worker aus dem DB. Gibt true zurück, wenn die Operation erfolgreich war, ansonsten false.
				
				\item \textit{public Worker getWorker(uint64\_t worker\_id)} Gibt den Worker mit der angegebenen ID zurück.
				
				\item \textit{public std::vector<std::shared\_ptr<Worker>> getWorkers()} Gibt alle Workers zurück.
				
				\item \textit{public uint64\_t addJob(uint64\_t user\_id, JobConfig config, std::chrono::time\_point schedule\_time, std::string command)} Fügt einen Job zur Datenbank hinzu und gibt seine ID zurück. 
				
				\item \textit{public bool removeJob(uint64\_t job\_id)} Löscht einen Job aus dem DB. Gibt true zurück, wenn die Operation erfolgreich war, ansonsten false.
				
				\item \textit{public Job getJob(uint64\_t job\_id)} Gibt den Job mit der angegebenen ID zurück.
				
				\item \textit{public std::vector<std::shared\_ptr<Job>> getJobs()} Gibt alle Jobs zurück.
				
				\item \textit{public uint64\_t addUser(std::string name, std::string email, int auth\_key)} Fügt einen User zur Datenbank hinzu und gibt seine ID zurück. 
				
				\item \textit{public bool removeUser(uint64\_t user\_id)} Löscht einen User aus dem DB. Gibt true zurück, wenn die Operation erfolgreich war, ansonsten false.
				
				\item \textit{public User getUser(uint64\_t user\_id)} Gibt den User mit der angegebenen ID zurück.
				
				\item \textit{public std::vector<std::shared\_ptr<User>> getUsers()} Gibt alle Users zurück.
				
				\item \textit{public bool startJob(uint64\_t job\_id, uint64\_t worker\_id, specs specs, std::chrono::time\_point start\_time)} Aktualisiert den Eintrag eines Jobs in der Datenbank mit einer Startzeit, den zugewiesenen Ressourcen und dem zugeordneten Mitarbeiter. Gibt true zurück, wenn die Operation erfolgreich war, ansonsten false.
				
				\item \textit{public bool finishJob(uint64\_t job\_id, std::chrono::time\_point finish\_time, std::string stdout, int8\_t exit\_code)} Aktualisiert den Eintrag eines Jobs mit Endzeit, Ausgabe und Exitcode. Gibt true zurück, wenn die Operation erfolgreich war, ansonsten false.
				
				\item \textit{public job\_result getJobResult(uint64\_t job\_id)} Gibt die Ergebnisse eines \textbf{fertigen} Jobs zurück.
								
			\end{itemize}
			
	\end{itemize}
\subsubsection{Gateway}

Die Gateway-Klasse verbindet sich mit der Datenbank und führt die SQL-Queries aus.

\begin{itemize}[label={}]

	\item \textit{\textbf{Attribute}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{QSqlDatabase db} Verwaltet die Verbindung zur Datenbank. 
		\end{itemize}

	\item \textit{\textbf{Methoden}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{public uint64\_t addWorker(int auth\_key, int space, int ram, int cores, std::string address)} Fügt einen Worker zur Datenbank hinzu und gibt seine ID zurück.
				
				\item \textit{public bool removeWorker(int uint64\_t)} Löscht einen Worker aus dem DB. Gibt true zurück, wenn die Operation erfolgreich war, ansonsten false.
				
				\item \textit{public worker\_details getWorker(uint64\_t worker\_id)} Gibt die Daten des Workers mit der angegebenen ID zurück.
				
				\item \textit{public std::vector<std::shared\_ptr<worker\_details>> getWorkers()} Gibt die Daten jedes Mitarbeiters zurück.
				
				\item \textit{public uint64\_t addJob(uint64\_t user\_id, JobConfig config, std::chrono::time\_point schedule\_time, std::string command)} Fügt einen Job zur Datenbank hinzu und gibt seine ID zurück. 
				
				\item \textit{public bool removeJob(uint64\_t job\_id)} Löscht einen Job aus dem DB. Gibt true zurück, wenn die Operation erfolgreich war, ansonsten false.
				
				\item \textit{public job\_details getJob(uint64\_t job\_id)} Gibt die Daten des Jobs mit der angegebenen ID zurück.
				
				\item \textit{public std::vector<std::shared\_ptr<job\_details>> getJobs()} Gibt die Daten jedes Jobs zurück.
				
				\item \textit{public uint64\_t addUser(std::string name, std::string email, int auth\_key)} Fügt einen User zur Datenbank hinzu und gibt seine ID zurück. 
				
				\item \textit{public bool removeUser(uint64\_t user\_id)} Löscht einen User aus dem DB. Gibt true zurück, wenn die Operation erfolgreich war, ansonsten false.
				
				\item \textit{public user\_details getUser(uint64\_t user\_id)} Gibt die Daten des Users mit der angegebenen ID zurück
				
				\item \textit{public std::vector<std::shared\_ptr<user\_details>> getUsers()} Gibt die Daten jedes Users zurück.
				
				\item \textit{public bool startJob(uint64\_t job\_id, uint64\_t worker\_id, specs specs, std::chrono::time\_point start\_time)} Aktualisiert den Eintrag eines Jobs in der Datenbank mit einer Startzeit, den zugewiesenen Ressourcen und dem zugeordneten Mitarbeiter. Gibt true zurück, wenn die Operation erfolgreich war, ansonsten false.
				
				\item \textit{public bool finishJob(uint64\_t job\_id, std::chrono::time finish\_time, std::string stdout, int8\_t exit\_code)} Aktualisiert den Eintrag eines Jobs mit Endzeit, Ausgabe und Exitcode. Gibt true zurück, wenn die Operation erfolgreich war, ansonsten false.
				
				\item \textit{public job\_result getJobResult(uint64\_t job\_id)} Gibt die Ergebnisse eines \textbf{fertigen} Jobs zurück.
		\end{itemize}


\end{itemize}

\subsubsection{Factory}

Erzeugt Objekte aus gegebenen Daten.

\begin{itemize}[label={}]

	\item \textit{\textbf{Methoden}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{public Job createJob(job\_details info)} Erzeugt ein Job-Objekt.
			
			\item \textit{public Worker createWorker(worker\_details info)} Erzeugt ein Worker-Objekt.
			
			\item \textit{public User createUser(user\_details info)} Erzeugt ein User-Objekt.
		\end{itemize}


\end{itemize}
\subsubsection{struct \purl{user_details}}

Eine struct, die alle relevanten Userdaten kapselt.

\begin{itemize}[label={}]

	\item \textit{\textbf{Attribute}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{uint64\_t id} Eine eindeutige ID zur Identifizierung des Users.
			
			\item \textit{std::string name} Der Name des Users.
			
			\item \textit{std::string email} Die Email des Users.
			
			\item \textit{authkey} to be filled
		\end{itemize}


\end{itemize}

\subsubsection{struct specs}

Eine struct, die alle relevanten Hardware-Spezifikationen des Rechners kapselt.


\begin{itemize}[label={}]

	\item \textit{\textbf{Attribute}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{int space} Speicherplatz.
			
			\item \textit{int ram} Random-Access Memory.
			
			\item \textit{int cores} Anzahl der CPU-Kerne.
			
		\end{itemize}


\end{itemize}

\subsubsection{struct \purl{worker_details}}

Eine struct, die alle relevanten Workerdaten kapselt.


\begin{itemize}[label={}]

	\item \textit{\textbf{Attribute}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{uint64\_t id} Eine eindeutige ID zur Identifizierung des Workers.
			
			\item \textit{specs specs} Hardware-Spezifikationen des Rechners.
			
			\item \textit{std::string address}
			
			\item \textit{authkey} to be filled
		\end{itemize}


\end{itemize}
\clearpage

\subsubsection{struct \purl{job_details}}

Eine struct, die alle relevanten Jobdaten kapselt.

\begin{itemize}[label={}]

	\item \textit{\textbf{Attribute}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{JobConfig config} Enthält die Konfiguration eines Jobs.
			
			\item \textit{uint64\_t user\_id} Die ID des Users, der diesen Job gescheduled hat.
			
			\item \textit{int status} Der Statuscode eines Jobs.
			
			\item \textit{uint64\_t id} Eine eindeutige ID zur Identifizierung des Jobs.
			
			\item \textit{std::string command} Der Befehl des Jobs, der in der Befehlszeile eingegeben wurde.
			
			\item \textit{std::chrono::time\_point schedule\_time} Die Uhrzeit, zu der der Job gescheduled wurde.
			
			\item \textit{std::chrono::time\_point start\_time} Die Uhrzeit, zu der der Job gestartet wurde.
			
			\item \textit{std::chrono::time\_point finish\_time} Die Uhrzeit, zu der der Job beendet wurde.
			
			\item \textit{specs allocated\_specs} Die Hardware-Ressourcen, die dem Job zugewiesen wurden.

		\end{itemize}


\end{itemize}

\subsection{Configfiles}

\subsubsection{enum Priority}

Eine Aufzählung aller möglichen Prioritäten, die ein Job haben kann.

	\item \textit{\textbf{Items}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{low} Priorität für Jobs, deren zeitnahe Abarbeitung unwichtig ist.
			\item \textit{normal} Priorität für Jobs, die zeitnahe abgearbeitet werden sollen.
			\item \textit{high} Priorität für Jobs, die sehr schnell abgearbeitet werden müssen.
			\item \textit{emergency} Priorität für Jobs, die umgehend bearbeitet werden müssen. Der Scheduler kann eventuell sogar andere Jobs zeitweise unterbrechen um andere Jobs mit dieser Priorität zu bearbeiten.
		\end{itemize}


\subsubsection{JobConfig}

Eine Sammlung an allen möglichen Einstellungen, die beschreiben, wie ein Job bearbeitet, bzw. eingeplant werden soll.

\begin{itemize}[label={}]

	\item \textit{\textbf{Attribute}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{std::optional<uint32_t> min_ram_} Minimal benötigter Hauptspeicher
			\item \textit{std::optional<uint32_t> max_ram_} Maximal benötigter Hauptspeicher
			\item \textit{std::optional<uint32_t> min_cpu_count_} Minimal benötigte CPU Kerne
			\item \textit{std::optional<uint32_t> max_cpu_count_} Maximal zu verwendende CPU Kerne
			\item \textit{std::optional<bool> blocking_mode_} Ob der Client auf den Abschluss der Aufgabe wartet
			\item \textit{std::string email_} Zu benachrichtigende Adresse
			\item \textit{std::optional<Priority> priority_} Priorität des Jobs in der Warteschlange
			\item \textit{std::string image_} Zu verwendendes Docker Image
			\item \textit{std::optional<std::vector<std::string>> environment_} Liste an Umgebungsvariablen
			\item \textit{std::optional<bool> interruptible_} Ob der Job unterbrechbar ist.
			\item \textit{std::optional<std::filesystem::path> current_working_dir_} Verzeichnis, von dem aus der Job im Container ausgeführt werden soll.
		\end{itemize}

	\item \textit{\textbf{Methoden}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{JobConfig()} Erstellt eine leere JobConfig
			\item \textit{JobConfig(std::stringstream &)} Deserialisiert eine JobConfig aus dem übergebenen Stream
			\item \textit{JobConfig(std::filesystem::path &)} Lädt eine serialisierte JobConfig aus dem Dateisystem an dem angegebenen Pfad.
			\item \textit{void set_min_ram(std::optional<uint32_t>)} Setter für min_ram_
			\item \textit{void set_max_ram(std::optional<uint32_t>)} Setter für max_ram_
			\item \textit{void set_min_cpu_count(std::optional<uint32_t>)} Setter für min_cpu_count_
			\item \textit{void set_max_cpu_count(std::optional<uint32_t>)} Setter für max_cpu_count_
			\item \textit{void set_blocking_mode(std::optional<bool>)} Setter für blocking_mode_
			\item \textit{void set_email(std::string &)} Setter für email_
			\item \textit{void set_priority(std::optional<Priority>)} Setter für priority_
			\item \textit{void set_image(std::string &)} Setter für image_
			\item \textit{void set_environment(std::optional<std::vector<std::string>> &)} Setter für environment_
			\item \textit{void set_interruptible(std::optional<bool>)} Setter für interruptible_
			\item \textit{void set_current_working_dir(std::optional<std::filesystem::path> &)} Setter für
			current_working_dir_
			\item \textit{std_optional<uint32_t> min_ram()} Getter für min_ram_
			\item \textit{std_optional<uint32_t> max_ram()} Getter für max_ram_
			\item \textit{std_optional<uint32_t> min_cpu_count()} Getter für min_cpu_count_
			\item \textit{std_optional<uint32_t> max_cpu_count()} Getter für max_cpu_count_
			\item \textit{std_optional<bool> blocking_mode()} Getter für blocking_mode_
			\item \textit{std::string &email()} Getter für email_
			\item \textit{std_optional<Priority> priority()} Getter für priority_
			\item \textit{std::string &image()} Getter für image_
			\item \textit{std_optional<std::vector<std::string>> &environment()} Getter für environment_
			\item \textit{std_optional<bool> interruptible()} Getter für interruptible_
			\item \textit{std_optional<std::filesystem::path> &current_working_dir()} Getter für current_working_dir_
			\item \textit{void Serialize(std::stringstream &)} Schiebt die serialisierte JobConfig in den angegebenen Stream.
			\item \textit{void Save(std::filesystem::path &)} Speichert die JobConfig im Filesystem an der angegebenen Stelle. 
			\item \textit{void Merge(JobConfig &)} Füllt diese JobConfig mit Werten aus der übergebenen JobConfig auf. In beiden Configs vorhandene Werte werden nicht überschrieben.
		\end{itemize}


\end{itemize}

\subsubsection{SchedulerConfig}

Wrapper für eine Hashmap, der auch eine Möglichkeit zum Speichern und Laden ins Filesystem bietet und als Speicher für verschiedene Regeln beim Einplanen der Jobs dient.

\begin{itemize}[label={}]

	\item \textit{\textbf{Attribute}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{std::map<std::string, std::string> values_} Hashmap, die alle Regeln enthält.
		\end{itemize}

	\item \textit{\textbf{Methoden}}
		\begin{itemize}[label={\textbullet}]
			\item \textit{SchedulerConfig()} Erzeugt eine leere SchedulerConfig
			\item \textit{SchedulerConfig(std::filesystem::path &)} Lädt eine serialisierte SchedulerConfig aus dem Filesystem
			\item \textit{size_t count()} Gibt an wie viele Elemente sich in der Config befinden.
			\item \textit{Get(std::string &)} Gibt das Element zurück, das der übergebenen Regel zugeordnet wurde.
			\item \textit{Set(std::string &key, std::string &value)} Setzt den Wert der Regel mit dem übergebenen key auf den übergebenen Wert.
			\item \textit{Save(std::filesystem::path &)} Schreibt die Config in das Filesystem an die angegebene Stelle.
			\item \textit{Contains(std::string &)} Gibt an, ob sich in der Config eine Regel mit dem angegebenen key befindet.
		\end{itemize}


\end{itemize}


% Document ends here.
\printnoidxglossaries

\end{document}
